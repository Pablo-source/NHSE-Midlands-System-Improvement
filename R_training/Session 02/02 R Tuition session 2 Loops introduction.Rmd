---
title: "01 Loops in R into"
output:
  html_document:
    df_print: paged
---
### **AIM**
This module describes some control structures in R such as loops, exploring the different types of loops and its components. 

#### **1. Vectors**

We will start by introducing the use of **Vectors** to build our loops. Vectors are created in R by using the c() concatenate function. We saw this on the first R training session

```{r Vector using concatenate function, echo=TRUE}
x = c(1,2,3)
print(x)
```
As we saw in the first session, we can retrieve some properties from our vector. Also by using the c(:) operator, we ensure we run through all the lements from the left side of ":" until the number on the right side of the ":". 

This is a way of ensuring we account for all the different element in a vector

```{r New vector, echo=TRUE}
Vec <- c(1:5)
Vec

str(Vec)
```
<br>

#### **2. Basic Loop with a catch**
The loop is a dynamic control structure, that will allow us to iterate any action or script inside the loop by each of the elements we define in the index **i** component.

A loop is made of three distinctive sections: 

- The for statement
- The index defined in brackets ()
- The script to be looped through defined inside curly brackets {}

```{r Basic loop catch, echo=TRUE}
for (i in 5){
  print(i)
} 

```
For learning purposes, we have created the abov for loop. It has a small bug: 

- It will only return the last element (5)
- Because we have *not* specified we want all elements included in the (1:5) element
- This is a dynamic code where the i index is replaced by each value in vector 1:5
- The index i is iteratively replaced by each value in our vector
- The first bit of a loop is the for() statement: 
  -It will define the index that the loop will run over
- As a convention, we use i as the counter for each iteration

<br>

#### **3. Basic Loop** 

To understand how loops work internally, we can explore what each iteration of the index will output from the loop.

This is an example on how the loop will work manually: 

```{r Manual loop, echo=TRUE}
# This is how the loop will work manually
i <- 1
print(i)
i <- 2
print(i)
i <- 3
print(i)
```

Once the first iteration is complete, the for loops back to the geninning and replaces i with the next value in our 1:45 sequence (2 in this case).

The process is repeated until the loop reaches last value of the sequence.

This is very powerful as we can use it to iterate over different objects in R. We can use it to iterate over a vector to retrieve each of its elements, once at a time.

<br>

###### **3.1 First we need to create a vector to explain the catch**

Again, we produce a new vector

```{r}
# What is the difference between these two scripts?
Nvec <- c(1:5)
Vec

x <- c(1,2,3,4,5)
x
```
This is the way we will loop through all elements in a loop. Remember we always use brackets () for both the index section and the action inside the loop.

```{r Basic loop, echo=TRUE}
for (i in 1:5){
  
  print(i)
  
}
```
<br>

####  **4. Further modifications** 

Let's say you want to start looping through a vector or dataframe,not on the first element (because if might have the column names or row labels), and we want instead to start looping from the second element onwards.  

```{r Start on second element, echo=TRUE}
for (i in 1:5){
  print(i + 1)
}
```
<br>

####  **5.Loops practical application** 

We can use loops to run the same analysis through different elements, when it is a repetitive process that can be automated

For example, let's say we have the data set below: 
```{r}

Date<-c('Jan-11','Feb-11','Mar-11','Apr-11','May-11','Jun-11','Jul-11','Aug-11') 
ROA <-c(357,309,413,320,291,415,509,651)
R1A <-c(571,617,765,1214,815,2039,4626,6528)
R1H <-c(893,797,890,1270,1015,1746,4585,6782)
RA2 <-c(518,369,465,470,380,492,777,1173)
RRU  <-c(457,343,418,465,417,594,1195,1737)
Mydata<-cbind.data.frame(Date,ROA,R1A,R1H,RA2,RRU)
Mydata
```

<br>

####  **5.1 Idexing elements in a Dataframe**

Each element can be indexed, in rows and columns by its position in the Data frame. By using Square brackets **[** and **]**, we can select individual elements by **rows** first and **columns** later: 

This is the notation: [rows,columns]

For example, the first date of the Data frame will be indexed by [1,1] as it is the first element in rows and also in columns. 

In the same way, to obtain the first data point for trust R0A, we can select it by using the first row but the second column this time [1,2]

```{r First element, echo=TRUE}
Mydata[1,1]
Mydata[1,2]

```



```{r Indexing, echo=TRUE}
Mydata[,1]
range(1:5)
```
<br>

####  **5.2 Idexing Rows and Columns in a Dataframe** 

Following the same logic as in the previous section, the truly power of loops for automating reports, comes when we can apply a specific calculation to an entire row or column, and then we are able to loop through each of the columns or rows in our data set.

**Selecting ALL rows for a Specific column in the Data frame


We select all rows by leaving *blank* the first portion of the two square brakets, meaning that we can loop through *all" elements in that row. 
The above script will return all the dates in the Dataframe
```{r Selecting all rows, echo=TRUE}
All_rows <- Mydata[,1]
All_rows
```
The script below, will return all values for ROA and also all values for R1A trusts. 
```{r}
R0A_values <- Mydata[,2]
R0A_values
R0A_values <- Mydata[,3]
R0A_values
```
<br>

#### **5.3 Looping through elements in a dataframe**

In our previous example we created a data frame, we are going to use it to loop through all its 5 Trusts (ROA,R1A,R1H,RA2,RRU). Let's say that these are the number of Admissions on five trusts 

```{r Metric_one, echo=TRUE}
Date<-c(as.Date('2021-01-01','2021-02-01','2021-03-01','2021-04-01','2021-05-01','2021-06-01','2021-07-01','2021-08-01',format = "%Y-%m-%d"))
ROA <-c(357,309,413,320,291,415,509,651)
R1A <-c(571,617,765,1214,815,2039,4626,6528)
R1H <-c(893,797,890,1270,1015,1746,4585,6782)
RA2 <-c(518,369,465,470,380,492,777,1173)
RRU  <-c(457,343,418,465,417,594,1195,1737)
Metric_one<-cbind.data.frame(Date,ROA,R1A,R1H,RA2,RRU)
Metric_one
```

To achieve this we need to define a vector with all our Trusts
```{r Trust names vector,echo=TRUE }
ORG <-c('ROA','R1A','R1H','RA2','RRU')
ORG
```
We need to loop through the total number of organisations, so we use the length() function 

```{r}
NORG <-length(ORG)
NORG
```
And this will be the parameter that we will include in the loop inside our for statement

- The for (i) statement now includes (i in (1:NORG))
- This NORG is defined previously as NORG <- length(ORG)
- That means the for loop with iterate from element 1 to element i to the total number of Organisations included in our ORG vector
- By increasing the number or Organisations in our ORG vector we can easily expand this script to include extra number of trusts

```{r Loop for organisations, echo=TRUE}
for (i in (1:NORG)){
  print (i)
}

```
#### **5.4 Looping through *columns* in a data frame**

Now applying this same principle, we can obtain the number of Admissions by trust by entereing the Data frame name with an index into the loop.
In this instance, we have to use the [,i] indexing elements we saw in section 4.1 to loop through **columns**. 

As we can see, we obtain on each iteration of the loop the total number of admissions per month for each individual trust: Second row in the output corresponds to  ROA, third to R1A, and so on (R1H,RA2,RRU)

```{r Loop to obtain Admissions per trust, echo=TRUE}
for (i in (1:NORG)){
 Admt <- Mydata[,i]
 print(Admt)
}

```
#### **5.5 Plotting inside the loop**
 
 We can take advantage of the previous loop by placing a plot function inside the for() loop

#### **5.5.1 Create a Factor variable from Date** 

```{r Check variable names,echo=TRUE}
names(Mydata)
str(Mydata)
```
As we can see from the data set above, the Months are read by R as Factors, so they are not in Alfabetical order. We can fix this by defining month values based on its variable values, using the factor() function: 

```{r Months in right Order,echo=TRUE}
     # Create a variable for months
  month <-factor(Mydata$Date,levels=as.factor(Mydata$Date))  
  month
   # Create a variable for Trusts
  trusts <-c('ROA Manchester University NHS Foundation Trust',
             'R1A Herefordshire and Worcestershire Health and Care NHS Trust',
             'R1H Barts Health NHS Trust',
             'RA2 Royal Surrey County Hospital NHS Foundation Trust',
             'RRU London Ambulance Service NHS Trust')
  trusts
```
Now we can see the Date variable is ordered in the Jan-Dec standard months order.

#### **5.5.2 Building the plot (01-N). Create plotting spaces for n number of plots**

We use par() function to setup graphical parameters. In this instance, we use it with mfrow(), so specify a matrix with a fector defined by c(number of rows, number of cols) to populate it with our plots. mfrow() is a vector object a vector of the form c(nr, nc) as array on the device by columns (mfcol), or rows (mfrow), respectively.

Then we use outer and internal margins  oma(), mar() functions as well as axis cex.axis() setting functions to create some padding to make some space around our plots

```{r}
str(Mydata)
Mydata
```

For obtain the final output plot, we build it using a combination of several functions: 

1. **par()** function
  - Defines and setup the area where the plot is created. We include in this section the graphical parameters for the plot layout and its shape arrangement. 
  - This is the main function to define graphic object sin R. 
  - For this paricular example, we want to create a report with **three indicators** for each Trust. So we use par(mfrow=c(1,3)) to create the matrix that will be populated with three different plots.

1.1 Graphical parameters
  - **mfcol, mfrow**
  - > A vector of the form c(nr, nc). Subsequent figures will be drawn in an nr-by-nc array on the device by columns (mfcol), or rows (mfrow), respectively.

  - > In a layout with exactly two rows and columns the base value of "cex" is reduced by a factor of 0.83: if there are three or more of either rows or columns, the reduction factor is 0.66.

  -> Setting a layout resets the base value of cex and that of mex to 1.If either of these is queried it will give the current layout, so querying cannot tell you the order in which the array will be filled.

2. **plot()** function
- Standard R base function to plot each of the charts. we choose type="b" parameter to display dots and lines as marks on the same chart.

3. **title()** function: 
- The Title function is applied to the whole plotting area (This is why it goes outside the plot statement). We Loop through the trusts vectors defined previously, to ensure that each of the Trust names displayed in columns in our database are displayed as the main title for the individual Trust reports.

- For the Title function to be displayed, it must be placed after both the par and plot functions. The par() functions always goes first to create the plot area in R.

- xaxt = 'n' : 'Remove default Labels for Y axis', as we will replace it by our adhoc Month Labels. 
- type = "b" : 'Display dots and lines as marks on the same chart'

```{r plot_inside_loop,echo=TRUE}
  # c) Create the matrix to allocate the different graphics (par command)
  trusts <-c('ROA Manchester University NHS Foundation Trust',
             'R1A Herefordshire and Worcestershire Health and Care NHS Trust',
             'R1H Barts Health NHS Trust',
             'RA2 Royal Surrey County Hospital NHS Foundation Trust',
             'RRU London Ambulance Service NHS Trust')

for (i in (1:NORG)){
    par(mfrow=c(1,3),cex.axis=0.6,oma=c(1,1,1,1),mar=c(5,2,4,2),cex.lab=0.6)
         plot(Mydata[,i],
         xaxt='n',
      #   ylim=c(min(Mydata[,i])-0.1 * abs(min(Mydata[,i])),max(Mydata[,i])),
         type="b")
     # Importnat Title must be placed after the plot command
       title(main=trusts[i],font.main=4,cex.main=1.5,outer=TRUE)
    
       
}    
```


#### **5.5.3 Adding new plots to each of the par() graphical matrix spaces we have defined**
 Can Anyone tell me if there is something odd in the above plots?, when we try to produce one line chart for each of our five trusts? 

Define first metric for our plot

```{r First metric, echo=TRUE}
Date<-c(as.Date('2021-01-01','2021-02-01','2021-03-01','2021-04-01','2021-05-01','2021-06-01','2021-07-01','2021-08-01',format = "%Y-%m-%d"))
ROA <-c(357,309,413,320,291,415,509,651)
R1A <-c(571,617,765,1214,815,2039,4626,6528)
R1H <-c(893,797,890,1270,1015,1746,4585,6782)
RA2 <-c(518,369,465,470,380,492,777,1173)
RRU  <-c(457,343,418,465,417,594,1195,1737)
Metric_one<-cbind.data.frame(Date,ROA,R1A,R1H,RA2,RRU)
Metric_one
```


We include the second Metric to our report

```{r Second Metric,echo=TRUE}
Date<-c(as.Date('2021-01-01','2021-02-01','2021-03-01','2021-04-01','2021-05-01','2021-06-01','2021-07-01','2021-08-01',format = "%Y-%m-%d"))
ROA <-c(35,30,41,32,29,41,50,65)
R1A <-c(57,61,76,121,85,29,46,28)
R1H <-c(83,79,89,12,15,17,45,67)
RA2 <-c(51,36,46,47,38,49,77,17)
RRU  <-c(45,34,41,46,41,92,11,21)
Metric_two<-cbind.data.frame(Date,ROA,R1A,R1H,RA2,RRU)
Metric_two
```

- Following the same logic we have used to create our plot. We have seen that currently we had been able to populate **one** plot of the six defined in our loop:

- Now we have two metircs 
 
```{r plot_two_metrics_loop,echo=TRUE}
  # c) Create the matrix to allocate the different graphics (par command)
  trusts <-c('ROA Manchester University NHS Foundation Trust',
             'R1A Herefordshire and Worcestershire Health and Care NHS Trust',
             'R1H Barts Health NHS Trust',
             'RA2 Royal Surrey County Hospital NHS Foundation Trust',
             'RRU London Ambulance Service NHS Trust')

for (i in (1:NORG)){
  
    par(mfrow=c(2,3),cex.axis=0.6,oma=c(1,1,1,1),mar=c(5,2,4,2),cex.lab=0.6)
  # First plot (1-6)      
   plot(Metric_one[,i],xaxt='n',type="b")
  # Second plot (2-6)      
   plot(Metric_two[,i],xaxt='n',type="b")
  
    
     # Importnat Title must be placed after the plot command
       title(main=trusts[i],font.main=4,cex.main=1.5,outer=TRUE)
    
       
}   
```
- Finally we add the latest metric (metric number three) to complete our report

```{r Third Metric,echo=TRUE}
Date<-c(as.Date('2021-01-01','2021-02-01','2021-03-01','2021-04-01','2021-05-01','2021-06-01','2021-07-01','2021-08-01',format = "%Y-%m-%d"))
ROA <-c(25,26,27,26,25,26,27,26)
R1A <-c(17,18,18,19,17,16,18,19)
R1H <-c(83,83,83,82,83,82,83,82)
RA2 <-c(10,10,10,10,10,10,10,10)
RRU  <-c(30,30,30,30,30,30,30,30)
Metric_three<-cbind.data.frame(Date,ROA,R1A,R1H,RA2,RRU)
Metric_three
```

Below we can see our final script, we have changed the content of the for loop to go from 2 to NORG instad of 1 to NORG, can anyone tell me why?

```{r plot_three_metrics_loop,echo=TRUE}
  # c) Create the matrix to allocate the different graphics (par command)
  trusts <-c('ROA Manchester University NHS Foundation Trust',
             'R1A Herefordshire and Worcestershire Health and Care NHS Trust',
             'R1H Barts Health NHS Trust',
             'RA2 Royal Surrey County Hospital NHS Foundation Trust',
             'RRU London Ambulance Service NHS Trust')

for (i in (2:NORG)){
  
    par(mfrow=c(2,3),cex.axis=0.6,oma=c(1,1,1,1),mar=c(5,2,4,2),cex.lab=0.6)
  # First plot (1-6)      
   INDIC_ONE <- plot(Metric_one[,i],xaxt='n',type="b")
  # Second plot (2-6)      
   INDIC_TWO <- plot(Metric_two[,i],xaxt='n',type="b")
    # Second plot (2-6)      
   INDIC_THREE <- plot(Metric_three[,i],xaxt='n',type="b")
    
     # Importnat Title must be placed after the plot command
       title(main=trusts[i],font.main=4,cex.main=1.5,outer=TRUE)
    
       
}   
```

#### **6. Include overall report title and other formatting options**

We can complete the report by adding certain elements that will make our report useful to be distributed among our stakeholders: 

- Produce final report as PDF
- Change file output to create a single file for each trust
- Include marks and labels to for each plot
- Add a title at the bottom of the PDF output file to state the department that has produced the report "Rightcare Midlands and East- NHS England" 


1. Produce final output as .PDF (so we can email it)
1.1 Change file output to obtain a specific file for each trust, so we can automate the report distribution

We obtain this by addind the following two lines **before** the par() statement inside the loop

2. Include labels for each plot and each data point

```{r Include lables for each plot, eval=FALSE, include=FALSE}
  #                   main="Metric_one",
  #                   panel.first=grid())
  #  text(x=INDIC_ONE,y=Metric_one[,i],
  #       labels=format(Metric_one[,i],4),
  #       pos=3,cex=.75)  
```

This would be the final script for the final output, it would incloude all the new features we just described

```{r final report, echo=TRUE}
  
# 1. Define month for X axis
month <-factor(Mydata$Date,levels=as.factor(Mydata$Date))  
# 2. Setup list of trusts to run the report on
trusts <-c('ROA Manchester University NHS Foundation Trust',
             'R1A Herefordshire and Worcestershire Health and Care NHS Trust',
             'R1H Barts Health NHS Trust',
             'RA2 Royal Surrey County Hospital NHS Foundation Trust',
             'RRU London Ambulance Service NHS Trust')

# 3.DEFINE MAIN LOOP TO CREATE REPORT
    for (i in (2:NORG)) {
  
# 4. Setup PDF output. Create one file for each  trusts (paste comand ".pdf",sep="")
  #  report<-paste(trusts[i],".pdf",sep="")  # We put trusts[i-1] as i in 2 (2-1=1): So it startd with
    # b) Produce PDF file (pdf command)
 #   pdf(file=report,width=30,onefile=TRUE,paper="a4r")
    
# 5. Define graphic parameters 
    par(mfrow=c(2,3),cex.axis=0.6,oma=c(1,1,1,1),mar=c(5,2,4,2),cex.lab=0.6)
      
# 6. Create plots 
  # First plot (1-3)      
   INDIC_ONE <- plot(Metric_one[,i],xaxt='n',type="b",xaxt='n', 
                xlab= "Calculations used for Metric_one (Num; Denom)",
                ylab= "Total", 
                panel.first=grid(), main="First Metric")
axis(side=1, 1:length(Date), labels=Date)
text(Metric_one[,i],labels=Metric_one[,i],cex=0.6, pos=1) 
  # Second plot (2-3)      
   INDIC_TWO <- plot(Metric_two[,i],xaxt='n',type="b",xaxt='n', 
                xlab= "Calculations used for Metric_two (Num; Denom)",
                ylab= "Total", 
                panel.first=grid(), main="Second Metric")
axis(side=1, 1:length(Date), labels=Date)
text(Metric_two[,i],labels=Metric_two[,i],cex=0.6, pos=1) 
  # Third plot (3-3)      
   INDIC_THREE <- plot(Metric_three[,i],xaxt='n',type="b",xaxt='n', 
                xlab= "Calculations used for Metric_three (Num; Denom)",
                ylab= "Total", 
                panel.first=grid(), main="Third Metric")
axis(side=1, 1:length(Date), labels=Date)
text(Metric_three[,i],labels=Metric_three[,i],cex=0.6, pos=1)
    
# 7. Create titles for each individual plot  
  title(main=trusts[i],font.main=4,cex.main=1.5,outer=TRUE)
        
# 8. Create overall titles for the Department who produces the plot. To be displayed at the bottom of the report 
  mtext("Rightcare Midlands and East- NHS England ",side=1,outer=TRUE,cex=0.3)
    

       
}   
    
```


- This is just an small example on how to create a report using R to include three set of indicators and output one PDF output for each Trust


### TIPS
 - Check option (Knit on Save), so you don't have to save and knit your Markdown document into two different actions